#+TITLE: On practical Event Sourcing in Clojure
#+ID: ev-so-clj
#+DATE: 2017/09/11
* What is event sourcing and why do we do it?
The traditional approach to storing data stores the current state.
Event sourcing captures all changes to an application state as a sequence events, with the name specifically referring to the ability to source the current state of a domain object from all the events that describe changes to its state.
* What does an event look like?
An event is plain old data which describes a state transition. In Clojure, we can conveniently express this as a map:
#+BEGIN_SRC clojure
{:event/id "deadbeef"
 :event/type :event.type/item-renamed
 :item/id "foobar"
 :item/name "New Name"}
#+END_SRC
Event names should always be written in the past tense, this allows us to distinguish them easily from commands.
* What do our domain objects do?
Our domain objects contain methods that describe its behaviours. If our domain objects were inventory items, the methods might be:
- create
- deactivate
- rename
- check-in
- remove
Normally, we would expect for these methods to directly alter the properties of the object, but instead we will raise an event. Raising an event does two things: it appends the event to the objects 
* Applying events
Applying an event is where we change the state of the domain object
#+BEGIN_SRC clojure
(defn apply-event
  [item event]
  (let [{:keys [:item/name]} event]
    (assoc item :item/name name)))
#+END_SRC 

Or we can utilise Clojure's multimethods if we want to apply different events differently.

#+BEGIN_SRC clojure
(defmulti apply-event
  (fn [_ event]
    (:event/type event))

(defmethod apply-event
  :event.type/item-renamed
  [item event]
  (let [{:keys [:item/name]} event]
    (assoc item :item/name name)))
#+END_SRC

A nice idiom for this process of moving key-value pairs from one map to another uses [[https://clojuredocs.org/clojure.core/select-keys][select-keys]] and [[https://clojuredocs.org/clojure.core/merge][merge]], particularly where you want to move several kvs or where some have conflicting short form names.

#+BEGIN_SRC clojure
(defn apply-event
  [item event]
  (let [m (select-keys event [:item/name])]
    (merge item m)))
#+END_SRC
* Loading an aggregate
It might have occured to you that apply-event that takes two arguments of type X and Y, returning X, and so is usable with [[https://clojuredocs.org/clojure.core/reduce][reduce]].
As long as the first event in our list of events can be applied to a nil domain object, then we can apply a list of events as so:

#+BEGIN_SRC clojure
(reduce apply-event nil events)
#+END_SRC 

#+BEGIN_SRC clojure
(defn load-from-history
  [events]
  (reduce apply-event nil events))
#+END_SRC

This is the procedure to recreate current state from events, and is the core of what we mean when we say "event-sourcing".
* Aggregate behaviours
The state of a domain object can only change through applying an event.
So, if we want to add a function that changes the name of this domain object then we need to raise an event -- which means appending the event to the domain objects list of uncommitted events, and then applying that event.
Our domain object contains an entry =:event/changes= which stores events that we have not yet persisted. We will persist them later.
#+BEGIN_SRC clojure
(defn append-event
  [item event]
  (update item :event/changes
    #(concat % [event])))

(defn raise
  [item event]
  (-> item
      (append-event event)
      (apply-event event)))

(defn rename
  [item name]
  (let [{:keys [:item/id]} item]
    (if (empty? name)
      (throw (Exception. "New name is empty.")
      (raise item {:event/type :event.type/item-renamed
                   :item/id id
                   :item/name name})))
#+END_SRC

Another behaviour we will want is the ability to create an item. This will be called with a nil domain object, and so can be used as the first event in the list of events when calling =load-from-history=.

#+BEGIN_SRC clojure
(defn create
  [item id name]
  (raise item {:event/type :event.type/item-created
               :item/id id
               :item/name name}))
#+END_SRC
* Saving domain objects
I won't describe how to persist events here, as it very much depends on what storage you wish to use. However, be aware that traditional SQL databases can be used, and there are purpose made event stores, such as Greg Young's [[https://geteventstore.com/][Event Store]].
A repository will have two functions, =get-by-id= and =save=.

Assuming that you have two functions =get-events= and =save-events=, they can be written as such:

#+BEGIN_SRC clojure
(defn get
  [id]
  (load-from-history (get-events id))

(defn save
  [item]
  (let [{:keys [:item/id :event/changes]} item]
    (save-events id changes)))
#+END_SRC
** Streams
A domain object per stream
Construct stream name using the id and a stream prefix

#+BEGIN_SRC clojure
(def stream-prefix "item-")

(defn remove-prefix
  "Removes prefix if possible, returns the original string if not."
  [string prefix]
  (str/replace string (re-pattern (str "^" prefix)) ""))

(defn s->a [stream-id]
  (let [id (remove-prefix stream-id stream-prefix)]
    (if (= id stream-id)
      (throw (Exception. "Invalid stream id."))
      id)))

(defn a->s [id]
(str stream-prefix id)
#+END_SRC
* The difference between a command and an event
An event is a statement that something happened, and is understood to be a fact.
A command is an instruction to our application.
Because of this, events have a name in the past tense, such as "item renamed", whilst a command with have an imperative name, "rename item".

A command will not be necessarily successful, as the application can reject them such as if another item has that name already, or if the item already has that name!

Commands should be seen as being external, and not neccessarily knowing what effect they will have on the application.
** How do we receive commands?
* The command handler
A command arrives at the commands handler.
The command handler has a single external function, =handle=.
It's purpose is to retrieve the domain object from the repository, call whatever behaviour is appropriate, and then save the domain object, persisting its new events.

In good functional programming practice, I separate the IO and pure parts of this operation. =handle-pure= is a pure function which is passed the item so that it doesn't need to interact with the repository.

#+BEGIN_SRC clojure
(defmulti handle-pure
  (fn [item command]
    (:command/type command)))

(defn handle
  [command]
  (let [{:keys [:item/id]} command
        item (get-by-id id)]
    (-> item
        (handle-pure command)
        save)))
#+END_SRC

The =io!= macro can be used to wrap pieces of code that you know involve IO, and this will cause them to throw exceptions if they are used in a transaction.

We dispatch based on the type of command we receive. And although here, one command corresponds to one domain object behaviour, a command could cause several to be called.

#+BEGIN_SRC clojure
(defmethod handle-pure
  :command.type/create-item
  [item command]
  (let [{:keys [:item/id :item/name]} command]
    (if (nil? agg)
      (create item id name)
      item)

(defmethod handle-pure
  :command.type/rename-item
  [item command]
  (let [{:keys [:item/name]} command]
    (rename item name))
#+END_SRC
** What should go in the command handler, and what should go in the domain object's behaviours?
The general rule is that all business logic should be contained in the domain object's bahviours. An example of this would be if we learnt that there was a rule that item can only be named in all caps, and we should convert any lowercase letters. Because this is business logic, this should go in our aggregate.
* Namespacing
For a guide to how to namespace this, see my project [[https://github.com/DCPRevere/Demense][Demense]] which although not a exact replication of this code, follows it quite closely.
* Aggregate or domain object?
